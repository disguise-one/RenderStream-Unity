using System;
using UnityEngine;
using UnityEngine.Experimental.Rendering;

namespace Disguise.RenderStream
{
    /// <summary>
    /// <para>
    /// Makes explicit the hardware and software linear/sRGB conversion rules:
    /// https://learn.microsoft.com/en-us/windows/win32/direct3d10/d3d10-graphics-programming-guide-resources-data-conversion
    /// </para>
    /// 
    /// <para>The following operations will trigger a hardware conversion:</para>
    /// <para>* Copying between float and sRGB textures</para>
    /// <para>* Shader sampling from an sRGB texture</para>
    /// <para>* Shader output into an sRGB texture</para>
    ///
    /// <remarks>
    /// Assumes only blitting between textures, never copying which is more complex.
    /// Blitting will trigger a hardware conversion between _UNORM and _SRGB textures for example, while copying will not.
    /// </remarks>
    /// </summary>
    static class SRGBConversions
    {
        /// <summary>
        /// Describes the color space of data inside a texture
        /// </summary>
        public enum Space
        {
            /// <summary>
            /// sRGB color primaries + linear transfer function
            /// </summary>
            Linear,
            
            /// <summary>
            /// sRGB color primaries + sRGB transfer function
            /// </summary>
            sRGB
        }
        
        /// <summary>
        /// Represents a software color space conversion
        /// </summary>
        public enum Conversion
        {
            /// <summary>
            /// No hardware or software conversion
            /// </summary>
            None,
            
            /// <summary>
            /// <see cref="Space.Linear"/> to <see cref="Space.sRGB"/> applied by the hardware during a blit operation
            /// </summary>
            HardwareLinearToSRGB,
            
            /// <summary>
            /// <see cref="Space.sRGB"/> to <see cref="Space.Linear"/> applied by the hardware during a blit operation
            /// </summary>
            HardwareSRGBToLinear,
            
            /// <summary>
            /// <see cref="Space.Linear"/> to <see cref="Space.sRGB"/> applied by the shader code during a blit operation
            /// </summary>
            SoftwareLinearToSRGB,
            
            /// <summary>
            /// <see cref="Space.sRGB"/> to <see cref="Space.Linear"/> applied in by the shader code during a blit operation
            /// </summary>
            SoftwareSRGBToLinear
        }

        /// <summary>
        /// Represents the texture format
        /// </summary>
        public enum Texture
        {
            /// <summary>
            /// An sRGB texture (ex <see cref="GraphicsFormat.B8G8R8A8_SRGB"/>)
            /// </summary>
            sRGB,
            
            /// <summary>
            /// Any non-sRGB texture
            /// </summary>
            Other
        }

        /// <summary>
        /// Represents the a texture and its contents
        /// </summary>
        public readonly struct Descriptor
        {
            public Space colorSpace { get; }
            public Texture textureFormat { get; }

            public Descriptor(Space colorSpace, Texture textureFormat)
            {
                if (colorSpace == Space.Linear && textureFormat == Texture.sRGB)
                {
                    throw new ArgumentException($"{nameof(SRGBConversions)}: The combination of sRGB texture format" +
                                                $"and linear color space is not supported");
                }
                
                this.colorSpace = colorSpace;
                this.textureFormat = textureFormat;
            }
        }

        public static Texture GetTextureFormat(RenderTexture rt)
        {
            return GetTextureFormat(rt.graphicsFormat);
        }

        public static Texture GetTextureFormat(GraphicsFormat format)
        {
            return GraphicsFormatUtility.IsSRGBFormat(format)
                ? Texture.sRGB
                : Texture.Other;
        }
        
        public static Texture GetTextureFormat(Display display)
        {
            return display.requiresSrgbBlitToBackbuffer
                ? Texture.Other
                : Texture.sRGB;
        }

        /// <summary>
        /// Returns the descriptor for a RenderTexture generated by Unity during frame rendering.
        /// An sRGB texture is assumed to contain <see cref="Space.sRGB"/> data.
        /// Any other texture is assumed to contain <see cref="Space.Linear"/> data.
        /// </summary>
        public static Descriptor GetAutoDescriptor(RenderTexture rt)
        {
            return GetAutoDescriptor(rt.graphicsFormat);
        }
        
        /// <inheritdoc cref="GetAutoDescriptor(RenderTexture)"/>
        public static Descriptor GetAutoDescriptor(GraphicsFormat format)
        {
            var textureFormat = GetTextureFormat(format);
            
            return textureFormat switch
            {
                Texture.sRGB => new Descriptor(Space.sRGB, textureFormat),
                Texture.Other => new Descriptor(Space.Linear, textureFormat),
                _ => throw new ArgumentOutOfRangeException()
            };
        }
        
        public static Descriptor GetDisplayDescriptor(Display display)
        {
            var textureFormat = GetTextureFormat(display);
            return new Descriptor(Space.sRGB, textureFormat);
        }

        /// <returns>
        /// The software conversion to apply inside a blit shader to ensure color consistency between <paramref name="src"/> and <paramref name="dst"/>.
        /// </returns>
        /// <exception cref="InvalidOperationException">Invalid descriptor.</exception>
        public static Conversion GetConversion(Descriptor src, Descriptor dst)
        {
            (Space srcColor, Texture srcTex, Space dstColor, Texture dstTex) x = (src.colorSpace, src.textureFormat, dst.colorSpace, dst.textureFormat);

            return x switch
            {
                // Shader sampler color space: Linear
                { srcColor: Space.sRGB, srcTex: Texture.sRGB, dstColor: Space.sRGB, dstTex: Texture.sRGB } => Conversion.None,
                { srcColor: Space.sRGB, srcTex: Texture.sRGB, dstColor: Space.sRGB, dstTex: Texture.Other } => Conversion.SoftwareLinearToSRGB,
                { srcColor: Space.sRGB, srcTex: Texture.sRGB, dstColor: Space.Linear, dstTex: Texture.sRGB } => throw new InvalidOperationException(),
                { srcColor: Space.sRGB, srcTex: Texture.sRGB, dstColor: Space.Linear, dstTex: Texture.Other } => Conversion.HardwareSRGBToLinear,
                
                // Shader sampler color space: sRGB
                { srcColor: Space.sRGB, srcTex: Texture.Other, dstColor: Space.sRGB, dstTex: Texture.sRGB } => Conversion.SoftwareSRGBToLinear,
                { srcColor: Space.sRGB, srcTex: Texture.Other, dstColor: Space.sRGB, dstTex: Texture.Other } => Conversion.None,
                { srcColor: Space.sRGB, srcTex: Texture.Other, dstColor: Space.Linear, dstTex: Texture.sRGB } => throw new InvalidOperationException(),
                { srcColor: Space.sRGB, srcTex: Texture.Other, dstColor: Space.Linear, dstTex: Texture.Other } => Conversion.SoftwareSRGBToLinear,
                
                // Shader sampler color space: Linear
                { srcColor: Space.Linear, srcTex: Texture.Other, dstColor: Space.sRGB, dstTex: Texture.sRGB } => Conversion.HardwareLinearToSRGB,
                { srcColor: Space.Linear, srcTex: Texture.Other, dstColor: Space.sRGB, dstTex: Texture.Other } => Conversion.SoftwareLinearToSRGB,
                { srcColor: Space.Linear, srcTex: Texture.Other, dstColor: Space.Linear, dstTex: Texture.sRGB } => throw new InvalidOperationException(),
                { srcColor: Space.Linear, srcTex: Texture.Other, dstColor: Space.Linear, dstTex: Texture.Other } => Conversion.None,
                
                // Invalid source descriptor
                { srcColor: Space.Linear, srcTex: Texture.sRGB, dstColor: Space.sRGB, dstTex: Texture.sRGB } => throw new InvalidOperationException(),
                { srcColor: Space.Linear, srcTex: Texture.sRGB, dstColor: Space.sRGB, dstTex: Texture.Other } => throw new InvalidOperationException(),
                { srcColor: Space.Linear, srcTex: Texture.sRGB, dstColor: Space.Linear, dstTex: Texture.sRGB } => throw new InvalidOperationException(),
                { srcColor: Space.Linear, srcTex: Texture.sRGB, dstColor: Space.Linear, dstTex: Texture.Other } => throw new InvalidOperationException(),
                
                _ => throw new ArgumentOutOfRangeException()
            };
        }
    }
}
